import 'dart:developer';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_chat_app/core/constants/firestore_constants.dart';
import 'package:flutter_chat_app/core/models/conversation_model.dart';
import 'package:flutter_chat_app/core/models/message_model.dart';

import '../models/user_model.dart';

// ==================================================
// PURPOSE: A dedicated service to handle all interactions with Cloud Firestore.
// This abstracts all database logic, making the ViewModels cleaner and the
// data layer easier to manage.
// ==================================================
class DatabaseService {
  final FirebaseFirestore _firestore;

  DatabaseService(this._firestore);

  /// Creates a new user document in the 'users' collection.
  Future<void> createUser(UserModel user) async {
    try {
      await _firestore
          .collection(FirestoreConstants.usersCollection)
          .doc(user.uid)
          .set(user.toMap());
    } catch (e) {
      log("Error creating user in Firestore: $e");
      rethrow;
    }
  }

  /// Fetches a single user's data from Firestore.
  Future<UserModel?> getUser(String uid) async {
    try {
      DocumentSnapshot doc = await _firestore
          .collection(FirestoreConstants.usersCollection)
          .doc(uid)
          .get();
      if (doc.exists) {
        return UserModel.fromMap(doc);
      }
      return null;
    } catch (e) {
      log("Error getting user: $e");
      return null;
    }
  }

  /// Fetches multiple user documents in a single batch operation.
  Future<List<UserModel>> getUsersIn(List<String> uids) async {
    if (uids.isEmpty) return [];
    try {
      final querySnapshot = await _firestore
          .collection(FirestoreConstants.usersCollection)
          .where(FirestoreConstants.uid, whereIn: uids)
          .get();
      return querySnapshot.docs.map((doc) => UserModel.fromMap(doc)).toList();
    } catch (e) {
      log("Error getting users in batch: $e");
      return [];
    }
  }

  /// Fetches a real-time stream of all users except the current one.
  Stream<List<UserModel>> getUsersStream(String currentUserId) {
    return _firestore
        .collection(FirestoreConstants.usersCollection)
        .where(FirestoreConstants.uid, isNotEqualTo: currentUserId)
        .snapshots()
        .map((snapshot) {
          return snapshot.docs.map((doc) => UserModel.fromMap(doc)).toList();
        });
  }

  /// Fetches a real-time stream of conversations for a given user.
  Stream<List<ConversationModel>> getConversationsStream(String userId) {
    return _firestore
        .collection(FirestoreConstants.conversationsCollection)
        .where(FirestoreConstants.participantIds, arrayContains: userId)
        .orderBy(FirestoreConstants.lastMessageTimestamp, descending: true)
        .snapshots()
        .map((snapshot) {
          return snapshot.docs
              .map((doc) => ConversationModel.fromMap(doc))
              .toList();
        });
  }

  /// Checks if a conversation between two users exists, and creates one if it doesn't.
  /// Returns the unique ID of the conversation.
  Future<String> createOrGetConversation(
    String currentUserId,
    String otherUserId,
  ) async {
    // A consistent ID is generated by sorting the UIDs.
    List<String> sortedIds = [currentUserId, otherUserId]..sort();
    String conversationId = sortedIds.join('_');

    final conversationDoc = _firestore
        .collection(FirestoreConstants.conversationsCollection)
        .doc(conversationId);
    final docSnapshot = await conversationDoc.get();

    if (!docSnapshot.exists) {
      await conversationDoc.set({
        FirestoreConstants.participantIds: sortedIds,
        FirestoreConstants.lastMessage: '',
        FirestoreConstants.lastMessageTimestamp: FieldValue.serverTimestamp(),
      });
    }
    return conversationId;
  }

  /// Fetches a real-time stream of messages for a given conversation.
  Stream<List<MessageModel>> getMessagesStream(String conversationId) {
    return _firestore
        .collection(FirestoreConstants.conversationsCollection)
        .doc(conversationId)
        .collection(FirestoreConstants.messagesCollection)
        .orderBy(FirestoreConstants.timestamp, descending: true)
        .snapshots()
        .map(
          (snapshot) =>
              snapshot.docs.map((doc) => MessageModel.fromMap(doc)).toList(),
        );
  }

  /// Adds a new message to a conversation and updates the conversation's last message.
  Future<void> sendMessage(String conversationId, MessageModel message) async {
    // Add the message to the 'messages' sub-collection.
    await _firestore
        .collection(FirestoreConstants.conversationsCollection)
        .doc(conversationId)
        .collection(FirestoreConstants.messagesCollection)
        .add(message.toMap());

    // Update the parent conversation document with the latest message info.
    await _firestore
        .collection(FirestoreConstants.conversationsCollection)
        .doc(conversationId)
        .update({
          FirestoreConstants.lastMessage: message.text,
          FirestoreConstants.lastMessageTimestamp: message.timestamp,
        });
  }
}
